<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Hand: Rotación y Sonido Generativo</title>
    
    <!-- LIBRERÍAS DE IA -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.18.0/dist/tf-core.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.18.0/dist/tf-backend-webgl.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js" crossorigin="anonymous"></script>
    
    <!-- Motor 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Fuente -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@300;500&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI Layer */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            display: flex; flex-direction: column; gap: 10px;
            background: rgba(0, 0, 0, 0.75); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white; width: 220px;
            transform: scale(0.95); transform-origin: top left;
        }
        #ui-layer.disabled { opacity: 0.5; pointer-events: none; }
        h1 { font-family: 'Orbitron', sans-serif; font-size: 1.1rem; color: #00ffff; text-align: center; margin: 0 0 10px 0; border-bottom: 1px solid rgba(0,255,255,0.2); padding-bottom: 10px; }
        .control-group { display: flex; flex-direction: column; gap: 4px; margin-bottom: 5px; }
        label { font-size: 0.75rem; color: #aaa; font-weight: 500; }
        select, input[type="color"] { background: rgba(255, 255, 255, 0.1); border: 1px solid #444; color: white; padding: 6px; border-radius: 6px; width: 100%; box-sizing: border-box; }
        #midiSelect { background: rgba(0, 50, 50, 0.3); border: 1px solid #008888; color: #00ffff; }
        button { background: linear-gradient(45deg, #00ffff, #0088ff); border: none; padding: 10px; color: black; font-weight: bold; border-radius: 6px; cursor: pointer; font-family: 'Orbitron', sans-serif; margin-top: 10px; }
        button:disabled { background: #555; color: #888; cursor: not-allowed; }
        button.stop { background: linear-gradient(45deg, #ff4444, #cc0000); color: white; }

        /* Cámara */
        #cam-container {
            position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; z-index: 10;
            border-radius: 12px; overflow: hidden; border: 2px solid rgba(0, 255, 255, 0.3); background: #000;
        }
        #video, #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        #video { object-fit: cover; opacity: 0.6; }
        #status-overlay { position: absolute; top: 10px; width: 100%; text-align: center; color: #00ffff; font-size: 0.7rem; font-weight: bold; text-shadow: 0 1px 2px black; z-index: 20; }
        
        /* Loading */
        .loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 999; color: #00ffff; font-family: 'Orbitron', sans-serif; flex-direction: column; gap: 20px; transition: opacity 0.5s; }
        .spinner { width: 40px; height: 40px; border: 3px solid rgba(0,255,255,0.3); border-top: 3px solid #00ffff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <div id="loadingScreen" class="loading">
        <div class="spinner"></div>
        <div id="loadingText">Iniciando Sistemas...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="disabled">
        <h1>Cosmos Rotación</h1>
        <div class="control-group">
            <label>Salida MIDI</label>
            <select id="midiSelect"><option value="">Pulsa INICIAR</option></select>
        </div>
        <div class="control-group">
            <label>Forma</label>
            <select id="shapeSelect">
                <option value="saturn">Saturno</option>
                <option value="heart">Corazón</option>
                <option value="fireworks">Fuegos</option>
                <option value="flowers">Flor</option>
            </select>
        </div>
        <div class="control-group">
            <label>Color Base</label>
            <input type="color" id="colorPicker" value="#00ffff">
        </div>
        <div class="control-group">
            <label id="info-label" style="font-size: 0.65rem; color: #888;">Audio: Espacial</label>
        </div>
        <button id="startButton" disabled>CARGANDO...</button>
    </div>

    <div id="cam-container">
        <video id="video" playsinline></video>
        <canvas id="output-canvas"></canvas>
        <div id="status-overlay">Off</div>
    </div>

    <script>
        // --- CONFIGURACIÓN ---
        const config = { particleCount: 2500, smoothing: 0.15 };

        let state = {
            isPlaying: false,
            handOpenness: 0,
            handRotationX: 0, 
            handRotationY: 0,
            handRotationZ: 0,
            prevHandOpenness: 0,
            currentShape: 'saturn',
            baseColor: new THREE.Color(0x00ffff),
            
            // Audio State
            audioIntensity: 0,
            audioPitch: 440
        };

        // DOM Elements
        const video = document.getElementById('video');
        const outputCanvas = document.getElementById('output-canvas');
        const ctx = outputCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const statusOverlay = document.getElementById('status-overlay');
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingText = document.getElementById('loadingText');
        const shapeSelect = document.getElementById('shapeSelect');
        const colorPicker = document.getElementById('colorPicker');
        const midiSelect = document.getElementById('midiSelect');
        const uiLayer = document.getElementById('ui-layer');
        const infoLabel = document.getElementById('info-label');

        // MIDI & Audio
        let midiAccess = null;
        let midiOutput = null;
        let audioCtx = null;
        let osc1, osc2, oscLFO, noiseNode, masterGain, filterNode; // Sintetizador complejo

        // --- 1. MOTOR DE AUDIO GENERATIVO (Viento Cósmico) ---
        function initAudioEngine() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Nodo Maestro
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0; // Empieza en silencio
                masterGain.connect(audioCtx.destination);

                // Oscilador 1 (Dron bajo)
                osc1 = audioCtx.createOscillator();
                osc1.type = 'sine';
                osc1.frequency.value = 110; 
                const gain1 = audioCtx.createGain();
                gain1.gain.value = 0.5;
                osc1.connect(gain1).connect(masterGain);
                osc1.start();

                // Oscilador 2 (Armónico agudo)
                osc2 = audioCtx.createOscillator();
                osc2.type = 'triangle';
                osc2.frequency.value = 220;
                const gain2 = audioCtx.createGain();
                gain2.gain.value = 0.3;
                osc2.connect(gain2).connect(masterGain);
                osc2.start();

                // Ruido Rosa (Textura de viento/arena)
                const bufferSize = 2 * audioCtx.sampleRate;
                const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    output[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = output[i];
                    output[i] *= 3.5; 
                }
                noiseNode = audioCtx.createBufferSource();
                noiseNode.buffer = noiseBuffer;
                noiseNode.loop = true;
                
                // Filtro para el ruido (Se abre al abrir la mano)
                filterNode = audioCtx.createBiquadFilter();
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 200;
                
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.value = 0.4;
                
                noiseNode.connect(filterNode).connect(noiseGain).connect(masterGain);
                noiseNode.start();

            } catch (e) { console.error("Error Audio Engine", e); }
        }
        let lastOut = 0;

        function updateAudioEngine() {
            if (!audioCtx) return;

            // Mapeo: Apertura de mano -> Volumen general y Brillo del filtro
            const volumeTarget = 0.1 + (state.handOpenness * 0.4); 
            masterGain.gain.setTargetAtTime(volumeTarget, audioCtx.currentTime, 0.1);
            
            const filterFreq = 100 + (state.handOpenness * 4000); // 100Hz a 4000Hz
            filterNode.frequency.setTargetAtTime(filterFreq, audioCtx.currentTime, 0.1);

            // Mapeo: Rotación de mano -> Pitch (Tono)
            // Si la mano gira en Y (rotación muñeca), cambia la armonía
            const baseFreq = 110 + (Math.abs(state.handRotationZ) * 100);
            osc1.frequency.setTargetAtTime(baseFreq, audioCtx.currentTime, 0.2);
            osc2.frequency.setTargetAtTime(baseFreq * 1.5, audioCtx.currentTime, 0.2); // Quinta justa

            // MIDI CC para control externo
            if (midiOutput) {
                const ccMod = Math.floor(state.handOpenness * 127);
                const ccPan = Math.min(127, Math.max(0, Math.floor((state.handRotationZ + 1) * 64)));
                
                // Enviar solo si cambia para no saturar
                try {
                    midiOutput.send([0xB0, 1, ccMod]); // CC 1 Mod Wheel
                    midiOutput.send([0xB0, 10, ccPan]); // CC 10 Pan
                } catch(e){}
            }
        }

        // --- 2. GESTIÓN MIDI ---
        async function initMIDI() {
            if (!navigator.requestMIDIAccess) {
                midiSelect.innerHTML = "<option>Navegador sin MIDI</option>";
                midiSelect.disabled = true;
                return;
            }
            try {
                midiAccess = await navigator.requestMIDIAccess();
                updateMidiOutputs();
                midiAccess.onstatechange = updateMidiOutputs; 
                infoLabel.textContent = "Audio + MIDI Activo";
                infoLabel.style.color = "#00ff00";
            } catch (err) {
                console.warn("MIDI Error:", err);
                midiSelect.innerHTML = "<option>Bloqueado / Error</option>";
                midiSelect.disabled = true;
            }
        }
        function updateMidiOutputs() {
            midiSelect.innerHTML = "";
            const outputs = Array.from(midiAccess.outputs.values());
            if (outputs.length === 0) {
                midiSelect.innerHTML = "<option>Sin dispositivos</option>"; return;
            }
            outputs.forEach(output => {
                const option = document.createElement("option");
                option.value = output.id; option.text = output.name;
                midiSelect.add(option);
            });
            if(outputs.length > 0) midiOutput = outputs[0];
        }
        midiSelect.addEventListener('change', (e) => {
            if (midiAccess) midiOutput = midiAccess.outputs.get(e.target.value);
        });

        // --- 3. SISTEMA 3D ---
        let scene, camera, renderer, particles, geometry, material, pivotGroup;
        let positionsOriginal = []; 

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // GRUPO PIVOTE: Para rotar todo el conjunto
            pivotGroup = new THREE.Group();
            scene.add(pivotGroup);

            createParticles();

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createParticles() {
            if (particles) pivotGroup.remove(particles);
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            const sizes = new Float32Array(config.particleCount);

            for (let i = 0; i < config.particleCount; i++) {
                positions[i*3] = (Math.random()-0.5)*100;
                positions[i*3+1] = (Math.random()-0.5)*100;
                positions[i*3+2] = (Math.random()-0.5)*100;
                sizes[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            material = new THREE.PointsMaterial({
                size: 0.5, map: sprite, vertexColors: true,
                blending: THREE.AdditiveBlending, depthTest: false,
                transparent: true, opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            pivotGroup.add(particles);
            updateTargetShape();
        }

        // Formas 3D (Mismas formas que antes)
        function getPointOnSaturn(i) {
            const ratio = i / config.particleCount;
            let x, y, z;
            if (ratio < 0.4) { 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 4;
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else { 
                const angle = Math.random() * Math.PI * 2;
                const r = 6 + Math.random() * 6; 
                x = r * Math.cos(angle);
                z = r * Math.sin(angle);
                y = (Math.random() - 0.5) * 0.5; 
                const tilt = Math.PI / 6;
                const y_new = y * Math.cos(tilt) - z * Math.sin(tilt);
                const z_new = y * Math.sin(tilt) + z * Math.cos(tilt);
                y = y_new;
                z = z_new;
            }
            return { x, y, z };
        }
        function getPointOnHeart(i) {
            let t = Math.random() * Math.PI * 2;
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = (Math.random() - 0.5) * 5; 
            return { x: x * 0.4, y: y * 0.4, z: z };
        }
        function getPointFireworks(i) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 2 + Math.random() * 15; 
            return { x: r*Math.sin(phi)*Math.cos(theta), y: r*Math.sin(phi)*Math.sin(theta), z: r*Math.cos(phi) };
        }
        function getPointFlower(i) {
            const angle = i * 137.5 * (Math.PI / 180);
            const r = 0.5 * Math.sqrt(i);
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            const z = Math.sin(r * 0.5) * 2; 
            return { x: x * 0.5, y: y * 0.5, z: z };
        }

        function updateTargetShape() {
            positionsOriginal = [];
            const colorAttr = geometry.attributes.color;
            const baseC = state.baseColor;
            for (let i = 0; i < config.particleCount; i++) {
                let pos;
                switch (state.currentShape) {
                    case 'saturn': pos = getPointOnSaturn(i); break;
                    case 'heart': pos = getPointOnHeart(i); break;
                    case 'fireworks': pos = getPointFireworks(i); break;
                    case 'flowers': pos = getPointFlower(i); break;
                    default: pos = getPointOnSaturn(i);
                }
                positionsOriginal.push(pos);
                const variation = Math.random() * 0.2;
                colorAttr.setXYZ(i, baseC.r + variation, baseC.g + variation, baseC.b + variation);
            }
            colorAttr.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 4. ANIMACIÓN Y FÍSICA ---
        function animate() {
            requestAnimationFrame(animate);
            if (!state.isPlaying) {
                 if(pivotGroup) pivotGroup.rotation.y += 0.002;
                 renderer.render(scene, camera);
                 return;
            }

            const positions = geometry.attributes.position.array;
            const openFactor = state.handOpenness; 
            
            // --- NUEVA LÓGICA DE ROTACIÓN ---
            // Usamos interpolación lineal (lerp) para suavizar el movimiento de la cámara/objeto
            // basado en la rotación detectada de la mano
            const targetRotX = state.handRotationX * 1.5; // Amplificar un poco
            const targetRotZ = state.handRotationZ * 1.5;
            
            pivotGroup.rotation.x = THREE.MathUtils.lerp(pivotGroup.rotation.x, targetRotX, 0.1);
            pivotGroup.rotation.y += 0.002 + (state.handRotationZ * 0.05); // Rotar continuo si inclinas la mano
            pivotGroup.rotation.z = THREE.MathUtils.lerp(pivotGroup.rotation.z, -state.handRotationZ, 0.1);

            // Explosión de partículas basada en apertura
            const targetScale = 0.5 + (openFactor * 2.0);
            pivotGroup.scale.setScalar(THREE.MathUtils.lerp(pivotGroup.scale.x, targetScale, 0.05));

            for (let i = 0; i < config.particleCount; i++) {
                const target = positionsOriginal[i];
                const ix = i*3;
                let currX = positions[ix], currY = positions[ix+1], currZ = positions[ix+2];
                
                // Vibración caótica cuando el sonido sube
                const vibration = (openFactor) * 0.5; 
                
                currX += (target.x - currX) * 0.05 + (Math.random()-0.5)*vibration;
                currY += (target.y - currY) * 0.05 + (Math.random()-0.5)*vibration;
                currZ += (target.z - currZ) * 0.05 + (Math.random()-0.5)*vibration;

                positions[ix] = currX; positions[ix+1] = currY; positions[ix+2] = currZ;
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
            
            updateAudioEngine();
        }

        // --- 5. DETECCIÓN DE MANO (MediaPipe) ---
        function drawHand(keypoints) {
            ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.fillStyle = '#ff0000';
            const fingers = [[0, 1, 2, 3, 4], [0, 5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16], [0, 17, 18, 19, 20]];
            ctx.beginPath();
            ctx.moveTo(keypoints[0].x, keypoints[0].y); ctx.lineTo(keypoints[5].x, keypoints[5].y);
            ctx.moveTo(keypoints[0].x, keypoints[0].y); ctx.lineTo(keypoints[17].x, keypoints[17].y);
            ctx.moveTo(keypoints[5].x, keypoints[5].y); ctx.lineTo(keypoints[9].x, keypoints[9].y);
            ctx.lineTo(keypoints[13].x, keypoints[13].y); ctx.lineTo(keypoints[17].x, keypoints[17].y);
            fingers.forEach(finger => {
                for (let i = 0; i < finger.length - 1; i++) {
                    const start = keypoints[finger[i]];
                    const end = keypoints[finger[i+1]];
                    ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y);
                }
            });
            ctx.stroke();
            keypoints.forEach(kp => { ctx.beginPath(); ctx.arc(kp.x, kp.y, 3, 0, 2 * Math.PI); ctx.fill(); });
        }

        let handDetector;

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 320, height: 240, facingMode: 'user' }
            });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => { video.play(); outputCanvas.width = video.videoWidth; outputCanvas.height = video.videoHeight; resolve(video); };
            });
        }

        async function bootApp() {
            try {
                init3D();
                loadingText.textContent = "Cargando IA...";
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = { runtime: 'mediapipe', solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915', modelType: 'full' };
                handDetector = await handPoseDetection.createDetector(model, detectorConfig);
                loadingScreen.classList.add('hidden');
                uiLayer.classList.remove('disabled');
                startButton.textContent = "INICIAR";
                startButton.disabled = false;
            } catch (err) { loadingText.textContent = "Error: " + err.message; console.error(err); }
        }

        async function detectHands() {
            if (!state.isPlaying) return;
            const hands = await handDetector.estimateHands(video);

            if (hands.length > 0) {
                const hand = hands[0]; 
                const kp = hand.keypoints;
                drawHand(kp);

                // --- CÁLCULO DE ROTACIÓN AVANZADA ---
                const wrist = kp[0];
                const indexBase = kp[5];
                const pinkyBase = kp[17];
                const middleTip = kp[12];

                // 1. Apertura (Openness)
                const tipsIds = [4, 8, 12, 16, 20]; 
                let totalDist = 0;
                tipsIds.forEach(idx => {
                    const tip = kp[idx];
                    totalDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                });
                const avgDist = totalDist / 5;
                let openness = (avgDist - 30) / (120 - 30);
                openness = Math.max(0, Math.min(1, openness)); 
                state.handOpenness = state.handOpenness * 0.8 + openness * 0.2; // Suavizado

                // 2. Rotación Z (Inclinación Izquierda/Derecha - Roll)
                // Calculamos el ángulo entre la base del meñique y la base del índice
                const dx = indexBase.x - pinkyBase.x;
                const dy = indexBase.y - pinkyBase.y;
                let angleZ = Math.atan2(dy, dx); 
                // Normalizamos (0 radianes es horizontal)
                // MediaPipe coordenadas: Y crece hacia abajo.
                // Ajustamos para que 0 sea palma horizontal
                state.handRotationZ = (angleZ + Math.PI) * -1; // Invertir para Three.js

                // 3. Rotación X (Pitch - Inclinar mano hacia adelante/atrás)
                // Estimación cruda basada en la altura relativa del dedo medio vs muñeca
                // En 2D es difícil obtener pitch exacto, pero la distancia vertical relativa ayuda
                const pitchDist = wrist.y - middleTip.y; 
                state.handRotationX = (pitchDist / 200) - 0.5;

                statusOverlay.textContent = `Ap: ${(state.handOpenness*100).toFixed(0)}% | Rot: ${state.handRotationZ.toFixed(2)}`;

            } else {
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                statusOverlay.textContent = "Buscando mano...";
                state.handOpenness *= 0.9;
                state.handRotationZ *= 0.9;
            }
            requestAnimationFrame(detectHands);
        }

        // EVENTOS UI
        startButton.addEventListener('click', async () => {
            if (state.isPlaying) {
                location.reload(); 
            } else {
                startButton.textContent = "...";
                startButton.disabled = true;
                
                // INICIO DE AUDIO/MIDI
                initAudioEngine();
                if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
                await initMIDI(); 
                await setupCamera();
                
                state.isPlaying = true;
                startButton.textContent = "STOP";
                startButton.classList.add('stop');
                startButton.disabled = false;
                detectHands();
            }
        });

        shapeSelect.addEventListener('change', (e) => { state.currentShape = e.target.value; updateTargetShape(); });
        colorPicker.addEventListener('input', (e) => { state.baseColor = new THREE.Color(e.target.value); updateTargetShape(); });

        bootApp();

    </script>
</body>
</html>
