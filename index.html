<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Hand Controller</title>
    
    <!-- LIBRERÍAS DE IA -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.18.0/dist/tf-core.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.18.0/dist/tf-backend-webgl.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js" crossorigin="anonymous"></script>
    
    <!-- Motor 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Fuente -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@300;500&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }

        /* Interfaz de Usuario (UI) - Hacemos la ventana mucho más pequeña */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Menos espacio entre elementos */
            background: rgba(0, 0, 0, 0.6); /* Un poco más oscuro para contraste */
            backdrop-filter: blur(10px);
            padding: 15px; /* Menos padding */
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 200px; /* Más estrecho (antes 280px) */
            transition: opacity 0.5s;
            transform: scale(0.9); /* Escala general al 90% */
            transform-origin: top left;
        }
        
        #ui-layer.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem; /* Texto más pequeño */
            margin: 0 0 5px 0;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            text-align: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        label {
            font-size: 0.7rem; /* Etiquetas más pequeñas */
            color: #aaa;
        }

        select, input[type="color"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            color: white;
            padding: 4px; /* Inputs más compactos */
            border-radius: 6px;
            outline: none;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            font-size: 0.8rem;
        }

        button {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            padding: 8px; /* Botón más compacto */
            color: black;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        button:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }
        button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        button.stop { background: linear-gradient(45deg, #ff4444, #cc0000); color: white; }

        /* Contenedor de la Cámara */
        #cam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px; /* Un poco más grande para ver bien las líneas */
            height: 180px;
            z-index: 10;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background: #000;
        }

        /* Video y Canvas superpuestos */
        #video, #output-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1); /* Efecto espejo para ambos */
        }
        
        #video {
            object-fit: cover;
            opacity: 0.6; /* Un poco más oscuro para que resalten las líneas */
        }

        /* Overlay de estado sobre la cámara */
        #status-overlay {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
            color: #00ffff;
            font-size: 0.7rem;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 0 1px 2px black;
            z-index: 20;
        }
        
        .loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            flex-direction: column;
            gap: 20px;
            transition: opacity 0.5s;
        }
        
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(0,255,255,0.3);
            border-top: 3px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { opacity: 0; pointer-events: none; }

    </style>
</head>
<body>

    <div id="loadingScreen" class="loading">
        <div class="spinner"></div>
        <div id="loadingText">Iniciando Sistemas...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="disabled">
        <h1>Cosmos Ctrl</h1>
        
        <div class="control-group">
            <label>Forma</label>
            <select id="shapeSelect">
                <option value="saturn">Saturno</option>
                <option value="heart">Corazón</option>
                <option value="fireworks">Fuegos</option>
                <option value="flowers">Flor</option>
            </select>
        </div>

        <div class="control-group">
            <label>Color</label>
            <input type="color" id="colorPicker" value="#00ffff">
        </div>

        <div class="control-group">
            <label>Audio/MIDI</label>
            <div id="midiStatus" style="font-size: 0.65rem; color: #888;">Standby</div>
        </div>

        <button id="startButton" disabled>CARGANDO...</button>
    </div>

    <!-- Cámara + Canvas de Dibujo -->
    <div id="cam-container">
        <video id="video" playsinline></video>
        <canvas id="output-canvas"></canvas>
        <div id="status-overlay">Off</div>
    </div>

    <script>
        // --- CONFIGURACIÓN ---
        const config = {
            particleCount: 2000,
            handOpenThreshold: 0.7, 
            smoothing: 0.1
        };

        let state = {
            isPlaying: false,
            handOpenness: 0, 
            handX: 0, handY: 0,        
            currentShape: 'saturn',
            baseColor: new THREE.Color(0x00ffff),
            lastNoteTime: 0,
            noteInterval: 500 
        };

        // MIDI & Audio
        let midiOutput = null;
        let audioCtx = null; 
        const notesScale = [60, 62, 64, 65, 67, 69, 71, 72, 74, 76, 77, 79]; 

        // DOM Elements
        const video = document.getElementById('video');
        const outputCanvas = document.getElementById('output-canvas');
        const ctx = outputCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const statusOverlay = document.getElementById('status-overlay');
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingText = document.getElementById('loadingText');
        const shapeSelect = document.getElementById('shapeSelect');
        const colorPicker = document.getElementById('colorPicker');
        const midiStatus = document.getElementById('midiStatus');
        const uiLayer = document.getElementById('ui-layer');

        // --- 1. SISTEMA 3D ---
        let scene, camera, renderer, particles, geometry, material;
        let positionsOriginal = []; 

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;
            camera.position.y = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            createParticles();

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createParticles() {
            if (particles) scene.remove(particles);
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            const sizes = new Float32Array(config.particleCount);

            for (let i = 0; i < config.particleCount; i++) {
                positions[i*3] = (Math.random()-0.5)*100;
                positions[i*3+1] = (Math.random()-0.5)*100;
                positions[i*3+2] = (Math.random()-0.5)*100;
                sizes[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            material = new THREE.PointsMaterial({
                size: 0.5, map: sprite, vertexColors: true,
                blending: THREE.AdditiveBlending, depthTest: false,
                transparent: true, opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            updateTargetShape();
        }

        // Formas 3D
        function getPointOnSaturn(i) {
            const ratio = i / config.particleCount;
            let x, y, z;
            if (ratio < 0.4) { 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 4;
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else { 
                const angle = Math.random() * Math.PI * 2;
                const r = 6 + Math.random() * 6; 
                x = r * Math.cos(angle);
                z = r * Math.sin(angle);
                y = (Math.random() - 0.5) * 0.5; 
                const tilt = Math.PI / 6;
                const y_new = y * Math.cos(tilt) - z * Math.sin(tilt);
                const z_new = y * Math.sin(tilt) + z * Math.cos(tilt);
                y = y_new;
                z = z_new;
            }
            return { x, y, z };
        }

        function getPointOnHeart(i) {
            let t = Math.random() * Math.PI * 2;
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = (Math.random() - 0.5) * 5; 
            return { x: x * 0.4, y: y * 0.4, z: z };
        }

        function getPointFireworks(i) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 2 + Math.random() * 15; 
            return { x: r*Math.sin(phi)*Math.cos(theta), y: r*Math.sin(phi)*Math.sin(theta), z: r*Math.cos(phi) };
        }

        function getPointFlower(i) {
            const angle = i * 137.5 * (Math.PI / 180);
            const r = 0.5 * Math.sqrt(i);
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            const z = Math.sin(r * 0.5) * 2; 
            return { x: x * 0.5, y: y * 0.5, z: z };
        }

        function updateTargetShape() {
            positionsOriginal = [];
            const colorAttr = geometry.attributes.color;
            const baseC = state.baseColor;
            for (let i = 0; i < config.particleCount; i++) {
                let pos;
                switch (state.currentShape) {
                    case 'saturn': pos = getPointOnSaturn(i); break;
                    case 'heart': pos = getPointOnHeart(i); break;
                    case 'fireworks': pos = getPointFireworks(i); break;
                    case 'flowers': pos = getPointFlower(i); break;
                    default: pos = getPointOnSaturn(i);
                }
                positionsOriginal.push(pos);
                const variation = Math.random() * 0.2;
                colorAttr.setXYZ(i, baseC.r + variation, baseC.g + variation, baseC.b + variation);
            }
            colorAttr.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 2. ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            if (!state.isPlaying) {
                 if(particles) particles.rotation.y += 0.002;
                 renderer.render(scene, camera);
                 return;
            }

            const positions = geometry.attributes.position.array;
            const openFactor = state.handOpenness; 
            
            particles.rotation.y += 0.001 + (state.handX * 0.01);
            particles.rotation.x = (state.handY - 0.5) * 0.5;

            const targetScale = 0.5 + (openFactor * 1.5);
            particles.scale.setScalar(THREE.MathUtils.lerp(particles.scale.x, targetScale, 0.05));

            for (let i = 0; i < config.particleCount; i++) {
                const target = positionsOriginal[i];
                const ix = i*3;
                let currX = positions[ix], currY = positions[ix+1], currZ = positions[ix+2];
                const vibration = (1 - openFactor) * 0.2; 
                
                currX += (target.x - currX) * 0.05 + (Math.random()-0.5)*vibration;
                currY += (target.y - currY) * 0.05 + (Math.random()-0.5)*vibration;
                currZ += (target.z - currZ) * 0.05 + (Math.random()-0.5)*vibration;

                positions[ix] = currX; positions[ix+1] = currY; positions[ix+2] = currZ;
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
            handleAudioLogic();
        }

        // --- 3. AUDIO/MIDI ---
        function handleAudioLogic() {
            const minInterval = 80, maxInterval = 800;
            state.noteInterval = minInterval + (state.handOpenness * (maxInterval - minInterval));

            if (Date.now() - state.lastNoteTime > state.noteInterval) {
                playNote();
                state.lastNoteTime = Date.now();
            }
            if (midiOutput) {
                try { midiOutput.send([0xB0, 1, Math.floor(state.handOpenness * 127)]); } catch(e) {}
            }
        }

        function playNote() {
            const noteIndex = Math.floor(state.handX * notesScale.length);
            const safeIndex = Math.max(0, Math.min(noteIndex, notesScale.length - 1));
            const note = notesScale[safeIndex];
            const durationMs = state.handOpenness > 0.5 ? 500 : 80; 
            const velocity = 80 + Math.floor(Math.random() * 30); 

            geometry.attributes.color.setXYZ(0, 1, 1, 1); 
            geometry.attributes.color.needsUpdate = true;

            if (midiOutput) {
                try {
                    midiOutput.send([0x90, note, velocity]);
                    setTimeout(() => midiOutput.send([0x80, note, 0]), durationMs);
                    return;
                } catch (e) {}
            } 
            if (audioCtx) playInternalSynth(note, durationMs / 1000);
        }

        function playInternalSynth(midiNote, durationSec) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
            
            osc.type = state.handOpenness > 0.5 ? 'sine' : 'triangle'; 
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + durationSec);
            
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + durationSec + 0.1);
        }

        async function initMIDI() {
            try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) {}
            if (!navigator.requestMIDIAccess) {
                midiStatus.textContent = "Sin soporte MIDI. Audio Web OK.";
                return;
            }
            try {
                const midiAccess = await navigator.requestMIDIAccess();
                const outputs = Array.from(midiAccess.outputs.values());
                if (outputs.length > 0) {
                    midiOutput = outputs.find(o => o.name.includes("IAC")) || outputs[0];
                    midiStatus.textContent = `MIDI: ${midiOutput.name}`;
                    midiStatus.style.color = "#00ff00";
                } else {
                    midiStatus.textContent = "Sin Disp. MIDI. Audio Web OK.";
                }
            } catch (err) {
                midiStatus.textContent = "MIDI Bloqueado. Audio Web OK.";
                midiStatus.style.color = "#ff5555";
            }
        }

        // --- 4. DIBUJO DE MANO Y LÍNEAS VERDES ---
        function drawHand(keypoints) {
            ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // Estilos de dibujo
            ctx.strokeStyle = '#00ff00'; // Líneas verdes estilo MediaPipe
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ff0000';   // Puntos rojos

            // Definir dedos (índices de los puntos)
            const fingers = [
                [0, 1, 2, 3, 4],     // Pulgar
                [0, 5, 6, 7, 8],     // Índice
                [9, 10, 11, 12],     // Medio (conectaremos 0-9 abajo)
                [13, 14, 15, 16],    // Anular (conectaremos 0-13 abajo)
                [0, 17, 18, 19, 20]  // Meñique
            ];

            // Dibujar Conexiones
            ctx.beginPath();
            
            // Palma base
            ctx.moveTo(keypoints[0].x, keypoints[0].y);
            ctx.lineTo(keypoints[5].x, keypoints[5].y);
            ctx.moveTo(keypoints[0].x, keypoints[0].y);
            ctx.lineTo(keypoints[17].x, keypoints[17].y);
            ctx.moveTo(keypoints[5].x, keypoints[5].y);
            ctx.lineTo(keypoints[9].x, keypoints[9].y);
            ctx.lineTo(keypoints[13].x, keypoints[13].y);
            ctx.lineTo(keypoints[17].x, keypoints[17].y);

            // Dedos
            fingers.forEach(finger => {
                for (let i = 0; i < finger.length - 1; i++) {
                    const start = keypoints[finger[i]];
                    const end = keypoints[finger[i+1]];
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                }
            });
            ctx.stroke();

            // Dibujar Puntos
            keypoints.forEach(kp => {
                ctx.beginPath();
                ctx.arc(kp.x, kp.y, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // --- 5. DETECCIÓN ---
        let handDetector;

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 320, height: 240, facingMode: 'user' }
            });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    // Ajustar canvas al tamaño real del video
                    outputCanvas.width = video.videoWidth;
                    outputCanvas.height = video.videoHeight;
                    resolve(video);
                };
            });
        }

        async function bootApp() {
            try {
                init3D();
                loadingText.textContent = "Cargando IA...";
                
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'mediapipe', 
                    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915',
                    modelType: 'full'
                };
                
                handDetector = await handPoseDetection.createDetector(model, detectorConfig);
                
                loadingScreen.classList.add('hidden');
                uiLayer.classList.remove('disabled');
                startButton.textContent = "INICIAR";
                startButton.disabled = false;
                
            } catch (err) {
                loadingText.textContent = "Error: " + err.message;
            }
        }

        async function detectHands() {
            if (!state.isPlaying) return;

            const hands = await handDetector.estimateHands(video);

            if (hands.length > 0) {
                const hand = hands[0]; 
                const kp = hand.keypoints;
                
                // DIBUJAR ESQUELETO
                drawHand(kp);

                // Lógica de posición y apertura
                const palmBase = kp[0];
                state.handX = 1 - (palmBase.x / video.videoWidth); 
                state.handY = 1 - (palmBase.y / video.videoHeight);

                const wrist = kp[0];
                const tipsIds = [4, 8, 12, 16, 20]; 
                let totalDist = 0;
                tipsIds.forEach(idx => {
                    const tip = kp[idx];
                    totalDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                });
                
                const avgDist = totalDist / 5;
                const minOpen = 30, maxOpen = 120;
                let openness = (avgDist - minOpen) / (maxOpen - minOpen);
                openness = Math.max(0, Math.min(1, openness)); 

                state.handOpenness = state.handOpenness * (1 - config.smoothing) + openness * config.smoothing;
                statusOverlay.textContent = `Apertura: ${(state.handOpenness*100).toFixed(0)}%`;

            } else {
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height); // Limpiar si no hay mano
                statusOverlay.textContent = "Buscando mano...";
                state.handOpenness = state.handOpenness * 0.95; 
            }

            requestAnimationFrame(detectHands);
        }

        // EVENTOS UI
        startButton.addEventListener('click', async () => {
            if (state.isPlaying) {
                location.reload(); 
            } else {
                startButton.textContent = "...";
                startButton.disabled = true;
                await initMIDI();
                if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
                await setupCamera();
                state.isPlaying = true;
                startButton.textContent = "STOP";
                startButton.classList.add('stop');
                startButton.disabled = false;
                detectHands();
            }
        });

        shapeSelect.addEventListener('change', (e) => {
            state.currentShape = e.target.value;
            updateTargetShape();
        });

        colorPicker.addEventListener('input', (e) => {
            state.baseColor = new THREE.Color(e.target.value);
            updateTargetShape();
        });

        bootApp();

    </script>
</body>
</html>
